<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Anneau en flèches imbriquées</title>
  <style>
    :root {
      font-family: sans-serif;
    }

    body {
      max-width: 960px;
      margin: 20px auto;
      padding: 0 16px;
    }

    h1 {
      margin-bottom: 1rem;
    }

    form {
      display: flex;
      flex-flow: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    fieldset {
      /*display: flex;*/
      border: 1px solid #ccc;
      border-radius: 8px;
      /*padding: 0.75rem 1rem;*/
    }

    legend {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0 0.4rem;
    }

    label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      font-size: 0.9rem;
      margin: 0.35rem 0;
    }

    input[type="number"],
    input[type="text"] {
      flex: 1 1 auto;
      padding: 0.3rem 0.4rem;
      border: 1px solid #bbb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    input[type="number"] {
      max-width: 6rex;
    }
    label:has(input[type="text"]) {
        flex-direction: column;
    }


    button {
      display: block;
      cursor: pointer;
      margin-bottom:1em;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      border: 1px solid #0d6efd;
      background: #0d6efd;
      color: #fff;
      font-size: 0.95rem;
      justify-self: start;
    }

    svg {
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <h1>Graphique SVG en flèches imbriquées</h1>

  <form id="controls">
    <fieldset>
      <legend>Structure</legend>
      <label>
        Nb d’items :
        <input type="number" id="items" value="6" min="1" />
      </label>
      <label>
        Tailles personnalisées (ex. 1,3,1) :
        <input type="text" id="itemsSizes" value="" />
      </label>
    </fieldset>

    <fieldset>
      <legend>Géométrie</legend>
      <label>
        Ratio intérieur :
        <input type="number" id="ratio" value="0.6" step="0.05" min="0.00" max="0.95" />
      </label>
      <label>
        Séparation (°) :
        <input type="number" id="gap" value="3" step="0.5" min="0" max="25" />
      </label>
      <label>
        Flèche (°) :
        <input type="number" id="arrow" value="6" step="0.5" min="-45" max="45" />
      </label>
      <label>
        Offset :
        <input type="number" id="offset" value="0" step="1" min="-180" max="180" />
      </label>
      <label>
    </fieldset>

    <fieldset>
      <legend>Remplissage</legend>
      <label>
        Saturation :
        <input type="number" id="saturationFill" value="0.7" step="0.1" min="0" max="1" />
      </label>
      <label>
        Luminosité :
        <input type="number" id="lightnessFill" value="0.9" step="0.1" min="0" max="1" />
      </label>
      <label>
        Offset couleur :
        <input type="number" id="offsetColor" value="0" step="1" min="0" max="360" />
      </label>
      <label>
    </fieldset>

    <fieldset>
      <legend>Contour</legend>
      <label>
        Largeur (px) :
        <input type="number" id="stroke" value="5" step="1" min="0" max="40" />
      </label>
      <label>
        Saturation :
        <input type="number" id="saturationStroke" value="0.7" step="0.1" min="0" max="1" />
      </label>
      <label>
        Luminosité :
        <input type="number" id="lightnessStroke" value="0.5" step="0.1" min="0" max="1" />
      </label>
    </fieldset>

    <fieldset>
      <legend>Texte</legend>
      <label>
        Items :
        <textarea id="itemsText" style="width:12ex; height:5em;"></textarea>
      </label>
      <label>
        Taille :
        <input type="number" id="fontSize" value="40" step="1" min="1" max="400" />
      </label>
      <label>
        Font :
        <input id="font" type="text"/>
        <select id="fontFamily">
        </select>
      </label>
      <label>
        Variation :
        <select id="fontVariant">
        </select>
      </label>
      <label>
        Epaisseur :
        <select id="fontWeight">
        </select>
      </label>
      <label>
        Couleur :
        <select id="fontColor">
          <option value="black">Noir</option>
          <option value="white">Blanc</option>
          <option value="stroke">Contour</option>
          <option value="reverse">Inversée</option>
        </select>
      </label>

    </fieldset>

    <div id="svg-container"></div>

    <div>
      <button type="button" id="download">Télécharger le SVG</button>
      <button type="button" id="download-png">Télécharger le PNG</button>
  </div>
  </form>


  <script>
    const svgContainer = document.getElementById("svg-container");
    const controlsForm = document.getElementById("controls");
    const btnDownload = document.getElementById("download");

    const SIZE = 1000;
    const CENTER = { x: SIZE / 2, y: SIZE / 2 };
    const R_OUTER = SIZE/2 * 0.95;

    const FontFamily = [
        "serif"  ,     
        "sans-serif"  ,
        "system-ui"   ,
        "cursive"     ,
        "fantasy"     ,
        "math"        ,
        "monospace",
    ]

    const FontVariant = [
      "normal",
      "small-caps"
    ]

    const FontWeight = [
      "normal",
      "bold",
      "bolder",
      "lighter"
    ]

    for (ff of FontFamily) {
      const o = document.createElement('option');
      o.value = ff;
      o.innerText = ff;
      document.getElementById('fontFamily').appendChild(o);
    }

    for (ff of FontVariant) {
      const o = document.createElement('option');
      o.value = ff;
      o.innerText = ff;
      document.getElementById('fontVariant').appendChild(o);
    }

    for (ff of FontWeight) {
      const o = document.createElement('option');
      o.value = ff;
      o.innerText = ff;
      document.getElementById('fontWeight').appendChild(o);
    }

    const DEFAULT_CONF = {
      items: 6,
      itemsSizes: "",
      ratio: 0.6,
      gap: 3,
      arrow: 6,
      stroke: 2.5,
      saturationFill: 0.7,
      lightnessFill: 0.9,
      saturationStroke: 0.7,
      lightnessStroke: 0.5,
    };

    function readConfigFromInputs() {
      const config = {};
      for (const input of controlsForm.elements) {
        if (!(input instanceof HTMLInputElement) && 
            !(input instanceof HTMLTextAreaElement) && 
            !(input instanceof HTMLSelectElement)) continue;
        config[input.id] = input.type === "number" ? parseFloat(input.value) : input.value.trim();
      }
      return config;
    }

    function loadConfig() {
      const stored = JSON.parse(localStorage.getItem("ring-arrow-generator") || "{}" );
      const config = { ...DEFAULT_CONF, ...stored };
      for (const input of controlsForm.elements) {
        if ((!(input instanceof HTMLInputElement) && !(input instanceof HTMLTextAreaElement) && 
        !(input instanceof HTMLSelectElement)) || !(input.id in config)) continue;
        input.value = config[input.id];
      }
      return config;
    }

    function saveConfig(config) {
      localStorage.setItem("ring-arrow-generator", JSON.stringify(config));
    }

    function polarToCartesian(cx, cy, r, angleDeg) {
      const angleRad = (angleDeg) * Math.PI / 180; // -90 pour partir en haut
      return {
        x: cx + r * Math.cos(angleRad),
        y: cy + r * Math.sin(angleRad),
      };
    }

    function pt(x, y) {
      return { x, y };
    }

    function sub(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }

    function add(a, b) {
      return { x: a.x + b.x, y: a.y + b.y };
    }

    function midpoint(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    function pointOnCircle(center, r, angleDeg) {
      const t = (angleDeg * Math.PI) / 180;
      return {
        x: center.x + r * Math.cos(t),
        y: center.y + r * Math.sin(t),
      };
    }

    function lineThrough(P, Q) {
      return { P, Q };
    }

    function lineThroughParallelTo(point, line) {
      const dir = sub(line.Q, line.P);
      return { P: point, Q: add(point, dir) };
    }

    function reflectPointAcrossLine(P, L1, L2) {
      const vx = L2.x - L1.x;
      const vy = L2.y - L1.y;
      const len2 = vx * vx + vy * vy;
      if (len2 === 0) return { ...P };
      const t = ((P.x - L1.x) * vx + (P.y - L1.y) * vy) / len2;
      const proj = { x: L1.x + t * vx, y: L1.y + t * vy };
      return {
        x: 2 * proj.x - P.x,
        y: 2 * proj.y - P.y,
      };
    }

    function lineLineIntersection(l1, l2) {
      const { P: A, Q: B } = l1;
      const { P: C, Q: D } = l2;

      const a1 = B.y - A.y;
      const b1 = A.x - B.x;
      const c1 = a1 * A.x + b1 * A.y;

      const a2 = D.y - C.y;
      const b2 = C.x - D.x;
      const c2 = a2 * C.x + b2 * C.y;

      const det = a1 * b2 - a2 * b1;
      if (Math.abs(det) < 1e-9) {
        return null;
      }

      return {
        x: (b2 * c1 - b1 * c2) / det,
        y: (a1 * c2 - a2 * c1) / det,
      };
    }

    function vectorLength(v) {
      return Math.hypot(v.x, v.y);
    }

    function normalize(v) {
      const len = vectorLength(v);
      if (!len) {
        return { x: 0, y: 0 };
      }
      return { x: v.x / len, y: v.y / len };
    }

    function angleBisector(A, B, C) {
      const v1 = normalize(sub(A, B));
      const v2 = normalize(sub(C, B));
      const dir = normalize(add(v1, v2));
      if (Number.isNaN(dir.x) || Number.isNaN(dir.y)) {
        return { P: B, Q: { x: B.x - v1.y, y: B.y + v1.x } };
      }
      return { P: B, Q: add(B, dir) };
    }

    function reflectLineAcrossLine(line, axis) {
      const P1 = reflectPointAcrossLine(line.P, axis.P, axis.Q);
      const P2 = reflectPointAcrossLine(line.Q, axis.P, axis.Q);
      return { P: P1, Q: P2 };
    }

    function lineCircleIntersections(P, Q, C, r) {
      const dx = Q.x - P.x;
      const dy = Q.y - P.y;
      const fx = P.x - C.x;
      const fy = P.y - C.y;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = fx * fx + fy * fy - r * r;

      const disc = b * b - 4 * a * c;
      if (disc < 0) return [];

      const s = Math.sqrt(disc);
      const t1 = (-b - s) / (2 * a);
      const t2 = (-b + s) / (2 * a);

      const I1 = { x: P.x + t1 * dx, y: P.y + t1 * dy };
      const I2 = { x: P.x + t2 * dx, y: P.y + t2 * dy };

      const d1 = Math.hypot(I1.x - P.x, I1.y - P.y);
      const d2 = Math.hypot(I2.x - P.x, I2.y - P.y);

      return d1 <= d2 ? [I1, I2] : [I2, I1];
    }

    function nearestOf(points, P) {
      let nearest = null;
      for (const point of points) {
        if (
          nearest === null ||
          Math.hypot(point.x - P.x, point.y - P.y) < Math.hypot(nearest.x - P.x, nearest.y - P.y)
        ) {
          nearest = point;
        }
      }
      return nearest;
    }

    function lineThroughPerpendicularTo(point, line) {
      const dir = sub(line.Q, line.P);
      const perp = { x: -dir.y, y: dir.x };
      return { P: point, Q: add(point, perp) };
    }

    function hsvToHex(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      const [r, g, b] = [5, 3, 1].map((n) => Math.round(f(n) * 255));
      return `#${[r, g, b]
        .map((x) => x.toString(16).padStart(2, "0"))
        .join("")}`;
    }

    function buildArrowV2({
      O = pt(0, 0),
      angleE = 10,
      angleEO = 40,
      angleF = 90,
      rOuter = 160,
      rInner = 100,
    } = {}) {
      const E = pointOnCircle(O, rOuter, angleE);
      const EO = pointOnCircle(O, rOuter, angleEO);
      const h = lineThrough(O, E);
      const SO = reflectPointAcrossLine(EO, h.P, h.Q);
      const g = lineThroughParallelTo(EO, h);
      const inter_d_g = lineCircleIntersections(g.P, g.Q, O, rInner);
      const EI = nearestOf(inter_d_g, E);
      const F = pointOnCircle(O, rOuter, angleF);
      const i = lineThrough(F, O);
      const inter_d_i = lineCircleIntersections(i.P, i.Q, O, rInner);
      const C = nearestOf(inter_d_i, E);
      const D = midpoint(F, C);
      const k = lineThrough(E, D);
      const inter_d_h = lineCircleIntersections(h.P, h.Q, O, rInner);
      const G = nearestOf(inter_d_h, E);
      const l = lineThrough(D, G);
      const m = lineThroughParallelTo(EO, k);
      const n = lineThroughParallelTo(SO, k);
      const p = lineThroughParallelTo(EI, l);

      let EA;
      let q;
      if (angleF === angleE) {
        EA = midpoint(EO, EI);
        q = lineThroughPerpendicularTo(EA, lineThrough(EO, EI));
      } else {
        EA = lineLineIntersection(m, p);
        q = angleBisector(EO, EA, EI);
      }

      const nPrime = reflectLineAcrossLine(n, q);
      const inter_d_nPrime = lineCircleIntersections(nPrime.P, nPrime.Q, O, rInner);
      const SI = nearestOf(inter_d_nPrime, E);

      const SA = angleF === angleE ? midpoint(SO, SI) : lineLineIntersection(n, nPrime);

      return { EA, SA, SI, EI, SO, EO };
    }

    function buildArrowAtAngle(angle, conf, outerR) {
      return buildArrowV2({
        O: pt(CENTER.x, CENTER.y),
        angleE: angle,
        angleEO: angle - conf.gap,
        angleF: angle + conf.arrow,
        rOuter: outerR,
        rInner: outerR * conf.ratio,
      });
    }

    function createArrowSlice(item, outerR, total, conf) {
      const startArrow = buildArrowAtAngle(item.start, conf, outerR);
      const endArrow = buildArrowAtAngle(item.end, conf, outerR);

      const sweep = item.end - item.start;
      const largeArc = sweep > 180 ? 1 : 0;
      const innerR = outerR * conf.ratio;

      const d = [
        `M ${startArrow.SO.x} ${startArrow.SO.y}`,
        `A ${outerR} ${outerR} 0 ${largeArc} 1 ${endArrow.EO.x} ${endArrow.EO.y}`,
        `L ${endArrow.EA.x} ${endArrow.EA.y}`,
        `L ${endArrow.EI.x} ${endArrow.EI.y}`,
        `A ${innerR} ${innerR} 0 ${largeArc} 0 ${startArrow.SI.x} ${startArrow.SI.y}`,
        `L ${startArrow.SA.x} ${startArrow.SA.y}`,
        `Z`,
      ].join(" ");

      const fill = hsvToHex(item.hue, conf.saturationFill, conf.lightnessFill);
      const strokeColor = hsvToHex(item.hue, conf.saturationStroke, conf.lightnessStroke);
      item.strokeColor = strokeColor;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", d);
      path.setAttribute("fill", fill);
      path.setAttribute("stroke", strokeColor);
      path.setAttribute("stroke-width", conf.stroke);
      path.setAttribute("stroke-linejoin", "round");
      return path;
    }

    //function generateText(svg, startAngle, endAngle, innerR, outerR, index, total, conf) {
    function generateText(svg, item, outerR, total, conf) {
      const sweep = (item.end - item.start) % 360;
      const largeArc = sweep > 180 ? 1 : 0;
      const innerR = outerR * conf.ratio;
      let sweepFlag = 1;
      let textRadius = innerR + (outerR - innerR ) / 2 - conf.fontSize/3; // au milieu de l’anneau
      {
          const s = (item.start<=180)?item.start:360-item.start;
          const e = (item.end<=180)?item.end:360-item.end;
          if (s < e) {
            sweepFlag = 0;
            textRadius = innerR + (outerR - innerR ) / 2 + conf.fontSize*1/3; // au milieu de l’anneau
          }
          console.log(s, e, sweepFlag)
      }

        // -------- courbe de texte --------
        // on crée un arc un peu à l'intérieur pour que le texte ne touche pas le bord
        const textStart = item.start + conf.arrow; // léger décalage pour pas coller au bord
        const textEnd = item.end + conf.arrow/2;

        let tp1 = polarToCartesian(CENTER.x, CENTER.y, textRadius, textStart);
        let tp2 = polarToCartesian(CENTER.x, CENTER.y, textRadius, textEnd);
        const textSweep = textEnd - textStart;
        let textLargeArc = textSweep > 180 ? 1 : 0;

        const textPathId = `textPath-${item.index}`;
        const textPath = document.createElementNS("http://www.w3.org/2000/svg", "path");

        if (sweepFlag == 0) {
          const tp = tp1;
          tp1 = tp2;
          tp2 = tp;
        }

        textPath.setAttribute("id", textPathId);
        textPath.setAttribute(
          "d",
          [
            `M ${tp1.x} ${tp1.y}`,
            `A ${textRadius} ${textRadius} 0 ${textLargeArc} ${sweepFlag} ${tp2.x} ${tp2.y}`
          ].join(" ")
        );
        textPath.setAttribute("fill", "none");
        textPath.setAttribute("stroke", "none"); // invisible
        svg.appendChild(textPath);

        FontColors = {
          "black": () => "black",
          "white": () => "white",
          "stroke": (item) => item.strokeColor,
          "reverse": (item, conf) => hsvToHex(item.hue + 180, conf.saturationFill, conf.lightnessFill)
        }

        // le texte lui-même
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("font-size", conf.fontSize);
        text.setAttribute("font-family", conf.font?`${conf.font}, ${conf.fontFamily}`:conf.fontFamily);
        text.setAttribute("font-variant", conf.fontVariant);
        text.setAttribute("font-weight", conf.fontWeight);
        text.setAttribute("fill", FontColors[conf.fontColor](item, conf));
        //text.setAttribute("fill", "#000");

        const textPathElem = document.createElementNS("http://www.w3.org/2000/svg", "textPath");
        textPathElem.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${textPathId}`);
        textPathElem.setAttribute("startOffset", "50%"); // centré
        textPathElem.setAttribute("text-anchor", "middle");
        textPathElem.setAttribute("letter-spacing", sweepFlag?"0":conf.fontSize/10);
        textPathElem.textContent = item.text;

        text.appendChild(textPathElem);
        svg.appendChild(text);
      }

    function parseItems(config) {
      const texts = config.itemsText?.split("\n") ?? [];
      console.log("texts", texts)
      if (!config.itemsSizes) {
        const count = Math.max(1, Math.round(config.items));
        return Array.from({ length: count }, (_, index) => ({
          index,
          start: (360 + (config.offset || 0) + (index * 360) / count) % 360,
          end: (360 + (config.offset || 0) + ((index + 1) * 360) / count) % 360,
          hue: Math.round((config.offsetColor || 0) + (index * 360) / count),
          text: texts[index] || ''
        }));
      }


      const sizes = config.itemsSizes
        .split(",")
        .map((value) => parseFloat(value.trim()))
        .filter((value) => Number.isFinite(value) && value > 0);

      const sum = sizes.reduce((acc, value) => acc + value, 0);
      if (!sum) {
        return parseItems({ ...config, itemsSizes: "" });
      }

      let start = 0;
      return sizes.map((size, index) => {
        const sweep = (size / sum) * 360;
        const item = { index, start, end: start + sweep };
        start += sweep;
        return item;
      });
    }

    function renderSvg(config) {
      console.log("config", config)
      svgContainer.innerHTML = "";
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", SIZE/3);
      svg.setAttribute("height", SIZE/3);
      svg.setAttribute("viewBox", `0 0 ${SIZE} ${SIZE}`);

      const items = parseItems(config);
      console.log("items", items)
      for (const item of items) {
        svg.appendChild(createArrowSlice(item, R_OUTER, items.length, config));
        if (item.text) {
          generateText(svg, item, R_OUTER, items.length, config)
        }

      }

      svgContainer.appendChild(svg);
    }

    function generateSvgFromInputs() {
      const config = readConfigFromInputs();
      saveConfig(config);
      renderSvg(config);
    }

    function downloadSVG() {
      const svg = svgContainer.querySelector("svg");
      if (!svg) return;

      const serializer = new XMLSerializer();
      const source = serializer.serializeToString(svg);
      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "anneau-fleches.svg";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    const initialConfig = loadConfig();
    renderSvg(initialConfig);

    controlsForm.addEventListener("input", generateSvgFromInputs);
    btnDownload.addEventListener("click", downloadSVG);


function downloadPNG() {
  const svg = svgContainer.querySelector("svg");
  if (!svg) return;

  // Sérialiser le SVG
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svg);

  // Créer une image en mémoire
  const img = new Image();
  const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(svgBlob);

  img.onload = () => {
    const canvas = document.createElement("canvas");
    canvas.width = svg.width.baseVal.value;
    canvas.height = svg.height.baseVal.value;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    URL.revokeObjectURL(url);

    // Télécharger le PNG
    const pngURL = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = pngURL;
    a.download = "anneau-fleches.png";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  img.src = url;
}
const btnDownloadPNG = document.getElementById("download-png");
btnDownloadPNG.addEventListener("click", downloadPNG);
  </script>
</body>
</html>

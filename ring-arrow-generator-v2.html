<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Anneau en flèches imbriquées</title>
  <style>
    :root {
      font-family: sans-serif;
    }

    body {
      max-width: 960px;
      margin: 20px auto;
      padding: 0 16px;
    }

    h1 {
      margin-bottom: 1rem;
    }

    form {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      margin-bottom: 1.5rem;
    }

    fieldset {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    legend {
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0 0.4rem;
    }

    label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      font-size: 0.9rem;
      margin: 0.35rem 0;
    }

    input[type="number"],
    input[type="text"] {
      flex: 1 1 auto;
      padding: 0.3rem 0.4rem;
      border: 1px solid #bbb;
      border-radius: 4px;
      font-size: 0.95rem;
    }

    input[type="number"] {
      max-width: 90px;
    }

    button {
      cursor: pointer;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      border: 1px solid #0d6efd;
      background: #0d6efd;
      color: #fff;
      font-size: 0.95rem;
      justify-self: start;
    }

    svg {
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <h1>Graphique SVG en flèches imbriquées</h1>

  <form id="controls">
    <fieldset>
      <legend>Structure</legend>
      <label>
        Nb d’items :
        <input type="number" id="items" value="6" min="1" />
      </label>
      <label>
        Tailles personnalisées (ex. 1,3,1) :
        <input type="text" id="itemsSizes" value="" />
      </label>
    </fieldset>

    <fieldset>
      <legend>Géométrie</legend>
      <label>
        Ratio intérieur :
        <input type="number" id="ratio" value="0.6" step="0.05" min="0.00" max="0.95" />
      </label>
      <label>
        Séparation (°) :
        <input type="number" id="gap" value="3" step="0.5" min="0" max="25" />
      </label>
      <label>
        Flèche (°) :
        <input type="number" id="arrow" value="6" step="0.5" min="-25" max="25" />
      </label>
      <label>
        Contour (px) :
        <input type="number" id="stroke" value="2.5" step="0.5" min="0" max="10" />
      </label>
    </fieldset>

    <fieldset>
      <legend>Couleurs remplissage</legend>
      <label>
        Saturation :
        <input type="number" id="saturationFill" value="0.7" step="0.1" min="0" max="1" />
      </label>
      <label>
        Luminosité :
        <input type="number" id="lightnessFill" value="0.9" step="0.1" min="0" max="1" />
      </label>
    </fieldset>

    <fieldset>
      <legend>Couleurs contour</legend>
      <label>
        Saturation :
        <input type="number" id="saturationStroke" value="0.7" step="0.1" min="0" max="1" />
      </label>
      <label>
        Luminosité :
        <input type="number" id="lightnessStroke" value="0.5" step="0.1" min="0" max="1" />
      </label>
    </fieldset>

    <button type="button" id="download">Télécharger le SVG</button>
  </form>

  <div id="svg-container"></div>

  <script>
    const svgContainer = document.getElementById("svg-container");
    const controlsForm = document.getElementById("controls");
    const btnDownload = document.getElementById("download");

    const SIZE = 420;
    const CENTER = { x: SIZE / 2, y: SIZE / 2 };
    const R_OUTER = 160;

    const DEFAULT_CONF = {
      items: 6,
      itemsSizes: "",
      ratio: 0.6,
      gap: 3,
      arrow: 6,
      stroke: 2.5,
      saturationFill: 0.7,
      lightnessFill: 0.9,
      saturationStroke: 0.7,
      lightnessStroke: 0.5,
    };

    function readConfigFromInputs() {
      const config = {};
      for (const input of controlsForm.elements) {
        if (!(input instanceof HTMLInputElement)) continue;
        config[input.id] = input.type === "number" ? parseFloat(input.value) : input.value.trim();
      }
      return config;
    }

    function loadConfig() {
      const stored = JSON.parse(localStorage.getItem("ring-arrow-generator") || "{}" );
      const config = { ...DEFAULT_CONF, ...stored };
      for (const input of controlsForm.elements) {
        if (!(input instanceof HTMLInputElement) || !(input.id in config)) continue;
        input.value = config[input.id];
      }
      return config;
    }

    function saveConfig(config) {
      localStorage.setItem("ring-arrow-generator", JSON.stringify(config));
    }

    function pt(x, y) {
      return { x, y };
    }

    function sub(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }

    function add(a, b) {
      return { x: a.x + b.x, y: a.y + b.y };
    }

    function midpoint(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    function pointOnCircle(center, r, angleDeg) {
      const t = (angleDeg * Math.PI) / 180;
      return {
        x: center.x + r * Math.cos(t),
        y: center.y + r * Math.sin(t),
      };
    }

    function lineThrough(P, Q) {
      return { P, Q };
    }

    function lineThroughParallelTo(point, line) {
      const dir = sub(line.Q, line.P);
      return { P: point, Q: add(point, dir) };
    }

    function reflectPointAcrossLine(P, L1, L2) {
      const vx = L2.x - L1.x;
      const vy = L2.y - L1.y;
      const len2 = vx * vx + vy * vy;
      if (len2 === 0) return { ...P };
      const t = ((P.x - L1.x) * vx + (P.y - L1.y) * vy) / len2;
      const proj = { x: L1.x + t * vx, y: L1.y + t * vy };
      return {
        x: 2 * proj.x - P.x,
        y: 2 * proj.y - P.y,
      };
    }

    function lineLineIntersection(l1, l2) {
      const { P: A, Q: B } = l1;
      const { P: C, Q: D } = l2;

      const a1 = B.y - A.y;
      const b1 = A.x - B.x;
      const c1 = a1 * A.x + b1 * A.y;

      const a2 = D.y - C.y;
      const b2 = C.x - D.x;
      const c2 = a2 * C.x + b2 * C.y;

      const det = a1 * b2 - a2 * b1;
      if (Math.abs(det) < 1e-9) {
        return null;
      }

      return {
        x: (b2 * c1 - b1 * c2) / det,
        y: (a1 * c2 - a2 * c1) / det,
      };
    }

    function vectorLength(v) {
      return Math.hypot(v.x, v.y);
    }

    function normalize(v) {
      const len = vectorLength(v);
      if (!len) {
        return { x: 0, y: 0 };
      }
      return { x: v.x / len, y: v.y / len };
    }

    function angleBisector(A, B, C) {
      const v1 = normalize(sub(A, B));
      const v2 = normalize(sub(C, B));
      const dir = normalize(add(v1, v2));
      if (Number.isNaN(dir.x) || Number.isNaN(dir.y)) {
        return { P: B, Q: { x: B.x - v1.y, y: B.y + v1.x } };
      }
      return { P: B, Q: add(B, dir) };
    }

    function reflectLineAcrossLine(line, axis) {
      const P1 = reflectPointAcrossLine(line.P, axis.P, axis.Q);
      const P2 = reflectPointAcrossLine(line.Q, axis.P, axis.Q);
      return { P: P1, Q: P2 };
    }

    function lineCircleIntersections(P, Q, C, r) {
      const dx = Q.x - P.x;
      const dy = Q.y - P.y;
      const fx = P.x - C.x;
      const fy = P.y - C.y;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = fx * fx + fy * fy - r * r;

      const disc = b * b - 4 * a * c;
      if (disc < 0) return [];

      const s = Math.sqrt(disc);
      const t1 = (-b - s) / (2 * a);
      const t2 = (-b + s) / (2 * a);

      const I1 = { x: P.x + t1 * dx, y: P.y + t1 * dy };
      const I2 = { x: P.x + t2 * dx, y: P.y + t2 * dy };

      const d1 = Math.hypot(I1.x - P.x, I1.y - P.y);
      const d2 = Math.hypot(I2.x - P.x, I2.y - P.y);

      return d1 <= d2 ? [I1, I2] : [I2, I1];
    }

    function nearestOf(points, P) {
      let nearest = null;
      for (const point of points) {
        if (
          nearest === null ||
          Math.hypot(point.x - P.x, point.y - P.y) < Math.hypot(nearest.x - P.x, nearest.y - P.y)
        ) {
          nearest = point;
        }
      }
      return nearest;
    }

    function lineThroughPerpendicularTo(point, line) {
      const dir = sub(line.Q, line.P);
      const perp = { x: -dir.y, y: dir.x };
      return { P: point, Q: add(point, perp) };
    }

    function hsvToHex(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      const [r, g, b] = [5, 3, 1].map((n) => Math.round(f(n) * 255));
      return `#${[r, g, b]
        .map((x) => x.toString(16).padStart(2, "0"))
        .join("")}`;
    }

    function buildArrowV2({
      O = pt(0, 0),
      angleE = 10,
      angleEO = 40,
      angleF = 90,
      rOuter = 160,
      rInner = 100,
    } = {}) {
      const E = pointOnCircle(O, rOuter, angleE);
      const EO = pointOnCircle(O, rOuter, angleEO);
      const h = lineThrough(O, E);
      const SO = reflectPointAcrossLine(EO, h.P, h.Q);
      const g = lineThroughParallelTo(EO, h);
      const inter_d_g = lineCircleIntersections(g.P, g.Q, O, rInner);
      const EI = nearestOf(inter_d_g, E);
      const F = pointOnCircle(O, rOuter, angleF);
      const i = lineThrough(F, O);
      const inter_d_i = lineCircleIntersections(i.P, i.Q, O, rInner);
      const C = nearestOf(inter_d_i, E);
      const D = midpoint(F, C);
      const k = lineThrough(E, D);
      const inter_d_h = lineCircleIntersections(h.P, h.Q, O, rInner);
      const G = nearestOf(inter_d_h, E);
      const l = lineThrough(D, G);
      const m = lineThroughParallelTo(EO, k);
      const n = lineThroughParallelTo(SO, k);
      const p = lineThroughParallelTo(EI, l);

      let EA;
      let q;
      if (angleF === angleE) {
        EA = midpoint(EO, EI);
        q = lineThroughPerpendicularTo(EA, lineThrough(EO, EI));
      } else {
        EA = lineLineIntersection(m, p);
        q = angleBisector(EO, EA, EI);
      }

      const nPrime = reflectLineAcrossLine(n, q);
      const inter_d_nPrime = lineCircleIntersections(nPrime.P, nPrime.Q, O, rInner);
      const SI = nearestOf(inter_d_nPrime, E);

      const SA = angleF === angleE ? midpoint(SO, SI) : lineLineIntersection(n, nPrime);

      return { EA, SA, SI, EI, SO, EO };
    }

    function buildArrowAtAngle(angle, conf, outerR) {
      return buildArrowV2({
        O: pt(CENTER.x, CENTER.y),
        angleE: angle,
        angleEO: angle - conf.gap,
        angleF: angle + conf.arrow,
        rOuter: outerR,
        rInner: outerR * conf.ratio,
      });
    }

    function createArrowSlice(item, outerR, total, conf) {
      const startArrow = buildArrowAtAngle(item.start, conf, outerR);
      const endArrow = buildArrowAtAngle(item.end, conf, outerR);

      const sweep = item.end - item.start;
      const largeArc = sweep > 180 ? 1 : 0;
      const innerR = outerR * conf.ratio;

      const d = [
        `M ${startArrow.SO.x} ${startArrow.SO.y}`,
        `A ${outerR} ${outerR} 0 ${largeArc} 1 ${endArrow.EO.x} ${endArrow.EO.y}`,
        `L ${endArrow.EA.x} ${endArrow.EA.y}`,
        `L ${endArrow.EI.x} ${endArrow.EI.y}`,
        `A ${innerR} ${innerR} 0 ${largeArc} 0 ${startArrow.SI.x} ${startArrow.SI.y}`,
        `L ${startArrow.SA.x} ${startArrow.SA.y}`,
        `Z`,
      ].join(" ");

      const hue = Math.round((item.index / total) * 360);
      const fill = hsvToHex(hue, conf.saturationFill, conf.lightnessFill);
      const strokeColor = hsvToHex(hue, conf.saturationStroke, conf.lightnessStroke);

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", d);
      path.setAttribute("fill", fill);
      path.setAttribute("stroke", strokeColor);
      path.setAttribute("stroke-width", conf.stroke);
      path.setAttribute("stroke-linejoin", "round");
      return path;
    }

    function parseItems(config) {
      if (!config.itemsSizes) {
        const count = Math.max(1, Math.round(config.items));
        return Array.from({ length: count }, (_, index) => ({
          index,
          start: (index * 360) / count,
          end: ((index + 1) * 360) / count,
        }));
      }

      const sizes = config.itemsSizes
        .split(",")
        .map((value) => parseFloat(value.trim()))
        .filter((value) => Number.isFinite(value) && value > 0);

      const sum = sizes.reduce((acc, value) => acc + value, 0);
      if (!sum) {
        return parseItems({ ...config, itemsSizes: "" });
      }

      let start = 0;
      return sizes.map((size, index) => {
        const sweep = (size / sum) * 360;
        const item = { index, start, end: start + sweep };
        start += sweep;
        return item;
      });
    }

    function renderSvg(config) {
      svgContainer.innerHTML = "";
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", SIZE);
      svg.setAttribute("height", SIZE);
      svg.setAttribute("viewBox", `0 0 ${SIZE} ${SIZE}`);

      const items = parseItems(config);
      for (const item of items) {
        svg.appendChild(createArrowSlice(item, R_OUTER, items.length, config));
      }

      svgContainer.appendChild(svg);
    }

    function generateSvgFromInputs() {
      const config = readConfigFromInputs();
      saveConfig(config);
      renderSvg(config);
    }

    function downloadSVG() {
      const svg = svgContainer.querySelector("svg");
      if (!svg) return;

      const serializer = new XMLSerializer();
      const source = serializer.serializeToString(svg);
      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "anneau-fleches.svg";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    const initialConfig = loadConfig();
    renderSvg(initialConfig);

    controlsForm.addEventListener("input", generateSvgFromInputs);
    btnDownload.addEventListener("click", downloadSVG);
  </script>
</body>
</html>
